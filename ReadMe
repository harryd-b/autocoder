Recursive Code Builder
A proof-of-concept tool that iteratively generates and verifies code snippets using OpenAI’s ChatGPT in a step-by-step, conversation-driven workflow. Each piece of code is linted, tested, and re-verified until complete.

Table of Contents
Overview
Project Structure
Installation & Setup
Configuration
Usage
How It Works
Testing
Troubleshooting
Contributing
License
Overview
This project aims to demonstrate how one might build complex software through multiple interactions with ChatGPT, verifying each piece of generated code in a separate conversation and refining any incomplete or incorrect snippets. The process is designed to:

Ask clarifying questions until enough detail is available for a code snippet.
Generate code in small pieces.
Verify code for completeness (via ChatGPT in “verification mode”), then run lint and tests.
Refine code if incomplete, re-verifying until stable.
Manage conversation history in a rolling window to control token usage.
Persist conversation state in a JSON file for possible resumption.
Project Structure
arduino
Copy code
my_recursive_code_builder/
├── api_utils.py
├── config.yaml
├── conversation_manager.py
├── main.py
├── recursive_builder.py
├── verification.py
├── requirements.txt
└── tests/
    ├── test_api_utils.py
    ├── test_conversation_manager.py
    ├── test_verification.py
    ├── test_recursive_builder.py
    └── test_main.py
Below is a summary of each key module:

api_utils.py
Handles OpenAI API calls with tenacity-based retry logic.
verification.py
Verifies code using a separate ChatGPT conversation; also runs linting (flake8) and tests (pytest).
conversation_manager.py
Loads and saves conversation states in JSON, manages a sliding window to limit token usage.
recursive_builder.py
Contains the recursive logic for generating code, refining incomplete snippets, and handling clarifying questions (optionally in parallel).
main.py
Entry point that initializes logging, loads config, and starts the recursive process.
tests/
Contains unit tests for each module (using pytest and unittest.mock).
Installation & Setup
Clone the Repository

bash
Copy code
git clone https://github.com/harryd-b/autocoder.git
cd my_recursive_code_builder
Create a Virtual Environment (Recommended)

bash
Copy code
python3 -m venv venv
source venv/bin/activate  # On Windows, use `venv\Scripts\activate`
Install Dependencies

bash
Copy code
pip install -r requirements.txt
The requirements.txt file might look like:

Copy code
openai
tenacity
PyYAML
flake8
pytest
pytest-mock
Configure OpenAI
You need an OpenAI API key to use ChatGPT.

Sign up at https://platform.openai.com/
Generate an API key from your OpenAI dashboard.
Put this key into config.yaml under openai_api_key:.
Configuration
Open config.yaml to customize various parameters:

yaml
Copy code
openai_api_key: "YOUR_OPENAI_API_KEY"
model: "gpt-4"

max_depth: 10
max_conversation_length: 10
max_retries: 3

retry_base_seconds: 1.5
retry_max_seconds: 10

conversation_file: "conversation_state.json"
openai_api_key: Your OpenAI API key (required).
model: Which ChatGPT model to use (e.g., gpt-4, gpt-3.5-turbo).
max_depth: How deeply to recurse if code remains incomplete.
max_conversation_length: The “sliding window” size for conversation messages.
max_retries: Number of API call retries before giving up.
retry_base_seconds / retry_max_seconds: Tenacity-based exponential backoff parameters.
conversation_file: Where conversation history is stored locally.
Usage
Edit config.yaml

Make sure you’ve set openai_api_key to a valid key.
Adjust other parameters if desired.
Run the Main Script

bash
Copy code
python main.py
The script will:

Print logs to console (info, warnings, errors).
Start an interactive ChatGPT-style loop in code (no direct terminal prompts except for logging).
Create or update a JSON file (conversation_state.json) to store conversation history.
Observe Generated Code

Whenever a code snippet is verified complete, a .py file is created locally (e.g., root_part0.py, root_refined_0.py, etc.).
Check the logs to see lint/test results (run automatically by the script).
Resume or Revisit

Because conversation states are stored in conversation_state.json, you can stop the script and re-run it later.
If there’s more code to generate/refine, the script will pick up where it left off.
How It Works
Root Prompt:

The script starts with a system message: “You are ChatGPT. You will interact with the user to clarify requirements…”.
A user prompt: “I want to build a complex software application…”
ChatGPT’s Response:

ChatGPT might ask questions or provide code snippets in triple backticks.
For each code snippet, the script calls verification logic:
Verification: A separate ChatGPT prompt asks whether the code is complete. The response must be valid JSON with {"complete": ..., "feedback": ...}.
Lint & Tests: Lints with flake8, tests with pytest.
If incomplete, the script feeds ChatGPT the feedback and requests refinement.
Conversation Management:

The script saves conversation states in a JSON file.
A “sliding window” ensures old messages are trimmed to control token usage.
Parallelism:

Verifying multiple snippets is done with asyncio.gather.
Clarifying questions can also be processed in parallel, although real user input is simulated.
Testing
Run tests with:

bash
Copy code
python -m pytest tests
Unit Tests:
Each module (api_utils, conversation_manager, verification, recursive_builder, main) has corresponding tests under tests/.
Mocking:
Calls to OpenAI or file I/O are mocked so tests remain deterministic.
Lint & Code Style:
bash
Copy code
flake8 .
For asynchronous tests (e.g., @pytest.mark.asyncio), ensure you have pytest-asyncio installed.

Troubleshooting
OpenAI Rate Limits:
If you receive 429 errors (rate limits), the code will retry a few times using Tenacity. You may need to throttle requests or upgrade your OpenAI plan for heavier usage.
Empty or Incomplete Code:
ChatGPT sometimes returns partial answers or empty strings. The script attempts multiple refinements. Increase max_depth if needed.
Conversation State Issues:
If conversation_state.json becomes corrupt or you want to start fresh, just delete or rename it. The script will create a new one.
JSONDecodeError:
Occurs if ChatGPT returns non-JSON or if the partial code is not valid in some steps. The script should handle re-verification gracefully.
Contributing
Fork this repository.
Create a feature branch (git checkout -b feature/new-stuff).
Commit your changes (git commit -m "Implement new stuff").
Push to your fork (git push origin feature/new-stuff).
Open a Pull Request.
We welcome suggestions, bug reports, and PRs that improve or extend this project’s functionality (e.g., improved concurrency, better test coverage, more robust verification flows, etc.).

License
MIT License

This project is available as open source under the terms of the MIT License. Feel free to use, modify, and distribute with attribution.

Thank you for using the Recursive Code Builder! If you have any questions, suggestions, or feedback, open an issue or create a pull request. Happy coding!
